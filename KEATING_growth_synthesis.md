## Growth Synthesis
### *Paige Keating*

Going through my previous growth memos, I find it most interesting what I identified as having the most trouble with. It's a little funny to me now, considering the problems we've tackled this semester, that in the first project I seemed very concerned about getting good plot formatting and in fact identified it as my biggest issue. Immediately, it has me thinking about how my use of AI has evolved over the course of these projects, with plot formatting being something that I no longer put too much time into; I now generally create a very basic plot of what I want and have AI fix formatting to make good figures. I think this is a good example of something that I know how to do and can implement on my own, but that I can save time on by having AI clean up my initial implementation.

Project one really set the tone for the semester and definitely scared me. My coding experience was all in Jupyter notebooks, using mostly existing packages that didn't require manipulation, and I never had a formal coding class outside of the occasional "Python Bootcamp"/"Hello, world!" sessions that the department would have. I noted on my growth memo learning about classes, and I think that is something that I really do understand and have as a tool now. We used classes in a lot of our projects, including the final project, and I really like the versatility.

I struggled with project two. I really thought that I had approached it well, and given myself plenty of time, but I just wasn't prepared for the jump. The scale of the project was much larger than I expected. I spent a lot of time on it, but by the time I finished making my different integration methods work, there was still so many problems to tackle and so little time. After this one, I started doing cost/benefit analysis with every decision, where I wasn't sure about something or wanted to spend more time on it, but I felt like I needed to weigh what would be most important to the final project. 

I would say that the most important technique I learned in project 2 was modular design, but it was not particularly comprehensible or well-organized. In project 3, I improved on this a little bit, primarily in having functional programming in the source code and creating an analysis script to run and test your code. Scripting was not something I had any experience with, but I used it in the two projects since, and I think that with this final project I've really come to understand how to best structure and implement my code. It did cause me some trouble in project 3 because I had no idea what the format was supposed to look like; fortunately, some of my peers had experience writing code in this way, so I could lean on them for advice. 

On that note, I'd like to think about how working with other people helped me write better code. If I had issues with debugging code, I would go to AI for help. But I found that I got great advice on bigger picture things about structure from my friends. For example, I hadn't seen the modular src + main analysis script structure before, so would occasionally ask my friend "Does this kind of function go in the source code or the analysis script", or "How should I import my modules". I'd like to think that I imparted some good advice that my peers could use, but I think that as independent as coding often is, I was able to absorb a lot of good practices just by working around people who had different experiences with programming. I hope that my final project shows how my approach to programming is vastly more organized and efficient than it was in project one.

Project three was also when I started giving AI-debugging a genuine try, whereas I was pretty reluctant to use it on the first two projects. Having learned from the first two projects, I knew that I wouldn't be able to solve every problem on my own within the time constraints. I remember there were so many lines of code in the packet propagation that when something was going wrong, I didn't know where to look, and just threw print statements everywhere. I don't think I would've been able to complete the rest of the project if I didn't use AI to identify the issue (packets were getting to boundaries, but getting stuck).

I honestly really liked project 4, at least for the concepts that it covered. I have actually used a modified MCMC package in my previous research, which fortunately had great documentation and tutorials, but as much as I could explain the gist of what it was doing, I didn't really know what things like "walkers" were when I saw them come up (by the way, if you're ever fitting planet orbital trajectories, it's called Orbits for the Impatient (OFTI)). I felt like the statistics side of the project actually made a lot of sense to me and wasn't too difficult to code, and fortunately the pseudocode for Metropolis-Hastings gave a great guideline for implementation. I will say that for future reference, I think we all found the HMC part of the project to be MUCH more difficult to implement than the MCMC. Understanding and implementing gradient descent was maybe the most difficult part of any of the projects for me. This was an instance of AI not really being helpful -- I tried giving it my code and seeing if it could figure out where I was getting NaNs or unreasonable log_prob, but I tried and deleted a lot of different solutions that didn't help. I ended up putting a print statement in between almost every step of my HMC code to try to identify where it was going wrong before I could pinpoint exactly where the issue was. This sounds like I didn't like this project, but I think I did, if not just for feeling accomplished.

I consider project 5 and the final project together. I think JAX is definitely a tool that I can and will use in the future, and I'm honestly surprised I've never heard of it before. With just a little bit of AI debugging for things like JIT tracing, I found that the structure made some sense to me, and it definitely sped up my N-body code. I will say that I was not looking forward to revisiting N-body dynamics. Project 2 was my weakest and since I ended up rewriting some of the force calculations in JAX from scratch for project 5, I'm still not entirely sure what was wrong with the way I was calculating it before (you may recall a lovely gif of stars floating away into space). 

I've written a lot of words, so I'll try to condense my final thoughts a little bit more succintly. After finishing the final project, I honestly feel like my ability and confidence in coding is leaps and bounds ahead of where it was at the beginning of the semester. Making a real, organized (I think) Python package does definitely feel like an accomplishment. I'd be really interested to see how my understanding of programming, MCMC, and AI debugging can apply to the kind of research I have been doing and want to do in the future; I've actually already thought about whether or not I'd be able to create an emulator like this one to handle planetary orbit parameters for multi-body systems (six parameters per orbit for >2 planets takes forever with basic MCMC). Generally, I thought the AI scaffolding worked for me and forced me to really understand what I was doing, kind of feeding into the "glass box" perspective. I'm not sure if the projects had the intended "build this to use later" effect for me, primarily because my first few projects were so unorganized and my style of programming changed so drastically so quickly that I ended up rewriting a lot of stuff or spending a lot of time trying to figure out what I had done -- some of it just plain didn't work. Overall, though, my conclusion for this class is that it was really difficult and overwhelming, but I can now say that I can code without feeling like a liar, so I consider it a success.